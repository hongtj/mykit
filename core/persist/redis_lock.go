package persist

import (
	"context"
	"math/rand"
	. "mykit/core/dsp"
	. "mykit/core/types"
	"strconv"
	"sync/atomic"
	"time"

	"github.com/go-redis/redis/v8"
)

const (
	letters     = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	lockCommand = `if redis.call("GET", KEYS[1]) == ARGV[1] then
    redis.call("SET", KEYS[1], ARGV[1], "PX", ARGV[2])
    return "OK"
else
    return redis.call("SET", KEYS[1], ARGV[1], "NX", "PX", ARGV[2])
end`
	delCommand = `if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("DEL", KEYS[1])
else
    return 0
end`
	randomLen = 16
	// default timeout to prevent deadlocks
	tolerance       = 500 // milliseconds
	millisPerSecond = 1000
)

const (
	spinInternal    = time.Millisecond * 5
	spinBigInternal = time.Millisecond * 20
)

func ConcurrencyCheck(ctx context.Context, cli *redis.Client, timeout int, key string, f Checker) (err error) {
	mutex := NewRedisLock(cli, key, timeout)
	err = mutex.ConcurrencyCheck(ctx, f)
	mutex.Release()

	return
}

func (rl *RedisLock) ConcurrencyCheck(ctx context.Context, f Checker) (err error) {
	acquired := false

	for {
		acquired, err = rl.Acquire()
		if err != nil {
			return
		}

		if acquired || time.Now().After(rl.deadline) {
			break
		}

		time.Sleep(spinInternal)
	}

	if !acquired {
		return ErrLockTimeout
	}

	err = f(ctx)

	return
}

// A RedisLock is a redis lock.
type RedisLock struct {
	// redis client
	store *redis.Client
	// Timeout time
	seconds  uint32
	deadline time.Time
	// lock key
	key string
	// Lock the value to prevent the lock from being accessed by others
	id string
}

// NewRedisLock returns a RedisLock.
func NewRedisLock(store *redis.Client, key string, timeout ...int) *RedisLock {
	res := &RedisLock{
		store: store,
		key:   key,
		// When getting a lock, the value of the lock is generated by a random string
		// Actually go-zero provides a more efficient way to generate random strings
		// See core/stringx/random.go: Randn
		id: randomStr(randomLen),
	}

	if len(timeout) > 0 {
		res.SetExpire(timeout[0])
		res.deadline = time.Now().Add(time.Second * time.Duration(timeout[0]))
	} else {
		res.deadline = time.Now().Add(time.Millisecond * time.Duration(tolerance-200))
	}

	return res
}

// Acquire acquires the lock.
func (rl *RedisLock) Acquire() (bool, error) {
	// Acquire the expiration time
	seconds := atomic.LoadUint32(&rl.seconds)
	// Default lock expiration time to prevent deadlocks
	resp, err := rl.store.Eval(
		Ctx,
		lockCommand,
		[]string{rl.key},
		[]string{
			rl.id, strconv.Itoa(int(seconds)*millisPerSecond + tolerance),
		},
	).Result()
	if err == redis.Nil {
		return false, nil
	} else if err != nil {
		LogS1.Error("RedisLock",
			LogEvent("acquiring"),
			LogProcessor(rl.key),
			LogError(err),
		)

		return false, err
	} else if resp == nil {
		return false, nil
	}
	reply, ok := resp.(string)
	if ok && reply == "OK" {
		return true, nil
	}

	LogS1.Error("RedisLock",
		LogEvent("acquiring reply"),
		LogProcessor(rl.key),
		LogDetail(resp),
		LogError(err),
	)

	return false, nil
}

// Release releases the lock.
func (rl *RedisLock) Release() (bool, error) {
	resp, err := rl.store.Eval(
		Ctx,
		delCommand,
		[]string{rl.key}, []string{rl.id},
	).Result()
	if err != nil {
		return false, err
	}

	reply, ok := resp.(int64)
	if !ok {
		return false, nil
	}

	return reply == 1, nil
}

// SetExpire sets the expire.
// Note that it needs to be called before Acquire()
// otherwise the default is 500ms auto-release
func (rl *RedisLock) SetExpire(seconds int) {
	atomic.StoreUint32(&rl.seconds, uint32(seconds))
}

func randomStr(n int) string {
	b := make([]byte, n)
	for i := range b {
		b[i] = letters[rand.Intn(len(letters))]
	}
	return string(b)
}
